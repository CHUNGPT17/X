From fbca8b0bbe49bc79b6ab04516095ee98d8ea4db7 Mon Sep 17 00:00:00 2001
From: Bo-Cun Chen <bc-bocun.chen@mediatek.com>
Date: Tue, 13 Jun 2023 22:37:57 +0800
Subject: [PATCH] 999-3014-ethernet-update-ppe-from-mt7986-to-mt7988

---
 drivers/net/ethernet/mediatek/mtk_eth_soc.c   |  26 +++--
 drivers/net/ethernet/mediatek/mtk_eth_soc.h   |  29 +++--
 drivers/net/ethernet/mediatek/mtk_ppe.c       | 106 +++++++++++++-----
 drivers/net/ethernet/mediatek/mtk_ppe.h       |  48 +++++++-
 .../net/ethernet/mediatek/mtk_ppe_offload.c   |  18 +--
 drivers/net/ethernet/mediatek/mtk_ppe_regs.h  |   5 +
 6 files changed, 171 insertions(+), 61 deletions(-)
 mode change 100755 => 100644 drivers/net/ethernet/mediatek/mtk_ppe_offload.c

diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.c b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
index f22a11a..1226c68 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.c
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.c
@@ -2191,7 +2191,8 @@ static int mtk_poll_rx(struct napi_struct *napi, int budget,
 		skb->dev = netdev;
 		skb_put(skb, pktlen);
 
-		if ((MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_RX_V2))) {
+		if ((MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_RX_V2)) ||
+		    (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))) {
 			reason = FIELD_GET(MTK_RXD5_PPE_CPU_REASON, trxd.rxd5);
 			hash = trxd.rxd5 & MTK_RXD5_FOE_ENTRY;
 			if (hash != MTK_RXD5_FOE_ENTRY)
@@ -4886,7 +4887,8 @@ static int mtk_probe(struct platform_device *pdev)
 	if (eth->soc->offload_version) {
 		u32 num_ppe;
 
-		num_ppe = MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ? 2 : 1;
+		num_ppe = MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3) ? 3 :
+			  MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ? 2 : 1;
 		num_ppe = min_t(u32, ARRAY_SIZE(eth->ppe), num_ppe);
 		for (i = 0; i < num_ppe; i++) {
 			u32 ppe_addr = eth->soc->reg_map->ppe_base[i];
@@ -5014,7 +5016,7 @@ static const struct mtk_soc_data mt2701_data = {
 	.has_accounting = false,
 	.hash_offset = 2,
 	.offload_version = 1,
-	.foe_entry_size = sizeof(struct mtk_foe_entry) - 16,
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 48,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma),
@@ -5036,7 +5038,7 @@ static const struct mtk_soc_data mt7621_data = {
 	.has_accounting = false,
 	.hash_offset = 2,
 	.offload_version = 1,
-	.foe_entry_size = sizeof(struct mtk_foe_entry) - 16,
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 48,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma),
@@ -5059,7 +5061,7 @@ static const struct mtk_soc_data mt7622_data = {
 	.has_accounting = true,
 	.hash_offset = 2,
 	.offload_version = 2,
-	.foe_entry_size = sizeof(struct mtk_foe_entry) - 16,
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 48,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma),
@@ -5081,7 +5083,7 @@ static const struct mtk_soc_data mt7623_data = {
 	.has_accounting = false,
 	.hash_offset = 2,
 	.offload_version = 1,
-	.foe_entry_size = sizeof(struct mtk_foe_entry) - 16,
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 48,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma),
@@ -5104,7 +5106,7 @@ static const struct mtk_soc_data mt7629_data = {
 	.has_accounting = true,
 	.hash_offset = 2,
 	.offload_version = 2,
-	.foe_entry_size = sizeof(struct mtk_foe_entry) - 16,
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 48,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma),
@@ -5126,7 +5128,7 @@ static const struct mtk_soc_data mt7986_data = {
 	.has_accounting = true,
 	.hash_offset = 4,
 	.offload_version = 2,
-	.foe_entry_size = sizeof(struct mtk_foe_entry),
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 32,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma_v2),
@@ -5149,7 +5151,7 @@ static const struct mtk_soc_data mt7981_data = {
 	.has_accounting = true,
 	.hash_offset = 4,
 	.offload_version = 2,
-	.foe_entry_size = sizeof(struct mtk_foe_entry),
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 32,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma_v2),
@@ -5169,6 +5171,10 @@ static const struct mtk_soc_data mt7988_data = {
 	.required_clks = MT7988_CLKS_BITMAP,
 	.required_pctl = false,
 	.has_sram = true,
+	.has_accounting = true,
+	.hash_offset = 4,
+	.offload_version = 2,
+	.foe_entry_size = sizeof(struct mtk_foe_entry),
 	.rss_num = 4,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma_v2),
@@ -5190,7 +5196,7 @@ static const struct mtk_soc_data rt5350_data = {
 	.has_accounting = false,
 	.hash_offset = 2,
 	.offload_version = 1,
-	.foe_entry_size = sizeof(struct mtk_foe_entry) - 16,
+	.foe_entry_size = sizeof(struct mtk_foe_entry) - 48,
 	.rss_num = 0,
 	.txrx = {
 		.txd_size = sizeof(struct mtk_tx_dma),
diff --git a/drivers/net/ethernet/mediatek/mtk_eth_soc.h b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
index c85f573..3554d14 100644
--- a/drivers/net/ethernet/mediatek/mtk_eth_soc.h
+++ b/drivers/net/ethernet/mediatek/mtk_eth_soc.h
@@ -1866,7 +1866,7 @@ struct mtk_eth {
 	struct timer_list		mtk_dma_monitor_timer;
 
 	u8				qos_toggle;
-	struct mtk_ppe			*ppe[2];
+	struct mtk_ppe			*ppe[3];
 	struct rhashtable		flow_table;
 };
 
@@ -1913,7 +1913,8 @@ mtk_foe_get_entry(struct mtk_ppe *ppe, u16 hash)
 
 static inline u32 mtk_get_ib1_ts_mask(struct mtk_eth *eth)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return MTK_FOE_IB1_BIND_TIMESTAMP_V2;
 
 	return MTK_FOE_IB1_BIND_TIMESTAMP;
@@ -1921,7 +1922,8 @@ static inline u32 mtk_get_ib1_ts_mask(struct mtk_eth *eth)
 
 static inline u32 mtk_get_ib1_ppoe_mask(struct mtk_eth *eth)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return MTK_FOE_IB1_BIND_PPPOE_V2;
 
 	return MTK_FOE_IB1_BIND_PPPOE;
@@ -1929,7 +1931,8 @@ static inline u32 mtk_get_ib1_ppoe_mask(struct mtk_eth *eth)
 
 static inline u32 mtk_get_ib1_vlan_tag_mask(struct mtk_eth *eth)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return MTK_FOE_IB1_BIND_VLAN_TAG_V2;
 
 	return MTK_FOE_IB1_BIND_VLAN_TAG;
@@ -1937,7 +1940,8 @@ static inline u32 mtk_get_ib1_vlan_tag_mask(struct mtk_eth *eth)
 
 static inline u32 mtk_get_ib1_vlan_layer_mask(struct mtk_eth *eth)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return MTK_FOE_IB1_BIND_VLAN_LAYER_V2;
 
 	return MTK_FOE_IB1_BIND_VLAN_LAYER;
@@ -1945,7 +1949,8 @@ static inline u32 mtk_get_ib1_vlan_layer_mask(struct mtk_eth *eth)
 
 static inline u32 mtk_prep_ib1_vlan_layer(struct mtk_eth *eth, u32 val)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return FIELD_PREP(MTK_FOE_IB1_BIND_VLAN_LAYER_V2, val);
 
 	return FIELD_PREP(MTK_FOE_IB1_BIND_VLAN_LAYER, val);
@@ -1953,7 +1958,8 @@ static inline u32 mtk_prep_ib1_vlan_layer(struct mtk_eth *eth, u32 val)
 
 static inline u32 mtk_get_ib1_vlan_layer(struct mtk_eth *eth, u32 val)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return FIELD_GET(MTK_FOE_IB1_BIND_VLAN_LAYER_V2, val);
 
 	return FIELD_GET(MTK_FOE_IB1_BIND_VLAN_LAYER, val);
@@ -1961,7 +1967,8 @@ static inline u32 mtk_get_ib1_vlan_layer(struct mtk_eth *eth, u32 val)
 
 static inline u32 mtk_get_ib1_pkt_type_mask(struct mtk_eth *eth)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return MTK_FOE_IB1_PACKET_TYPE_V2;
 
 	return MTK_FOE_IB1_PACKET_TYPE;
@@ -1969,7 +1976,8 @@ static inline u32 mtk_get_ib1_pkt_type_mask(struct mtk_eth *eth)
 
 static inline u32 mtk_get_ib1_pkt_type(struct mtk_eth *eth, u32 val)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return FIELD_GET(MTK_FOE_IB1_PACKET_TYPE_V2, val);
 
 	return FIELD_GET(MTK_FOE_IB1_PACKET_TYPE, val);
@@ -1977,7 +1985,8 @@ static inline u32 mtk_get_ib1_pkt_type(struct mtk_eth *eth, u32 val)
 
 static inline u32 mtk_get_ib2_multicast_mask(struct mtk_eth *eth)
 {
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 		return MTK_FOE_IB2_MULTICAST_V2;
 
 	return MTK_FOE_IB2_MULTICAST;
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.c b/drivers/net/ethernet/mediatek/mtk_ppe.c
index b876411..c4a630d 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.c
@@ -102,7 +102,7 @@ mtk_ppe_acct_data(struct mtk_ppe *ppe, u16 index)
 struct mtk_foe_accounting *mtk_ppe_mib_entry_read(struct mtk_ppe *ppe, u16 index)
 {
 	u32 byte_cnt_low, byte_cnt_high, pkt_cnt_low, pkt_cnt_high;
-	u32 val, cnt_r0, cnt_r1, cnt_r2;
+	u32 val, cnt_r0, cnt_r1, cnt_r2, cnt_r3;
 	struct mtk_foe_accounting *acct;
 	int ret;
 
@@ -120,14 +120,26 @@ struct mtk_foe_accounting *mtk_ppe_mib_entry_read(struct mtk_ppe *ppe, u16 index
 	cnt_r0 = readl(ppe->base + MTK_PPE_MIB_SER_R0);
 	cnt_r1 = readl(ppe->base + MTK_PPE_MIB_SER_R1);
 	cnt_r2 = readl(ppe->base + MTK_PPE_MIB_SER_R2);
+	if (MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V3))
+		cnt_r3 = readl(ppe->base + MTK_PPE_MIB_SER_R3);
 
-	byte_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R0_BYTE_CNT_LOW, cnt_r0);
-	byte_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R1_BYTE_CNT_HIGH, cnt_r1);
-	pkt_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R1_PKT_CNT_LOW, cnt_r1);
-	pkt_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R2_PKT_CNT_HIGH, cnt_r2);
+	if (MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V3)) {
+		byte_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R0_BYTE_CNT_LOW, cnt_r0);
+		byte_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R1_BYTE_CNT_HIGH_V2, cnt_r1);
+		pkt_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R2_PKT_CNT_LOW_V2, cnt_r2);
+		pkt_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R3_PKT_CNT_HIGH_V2, cnt_r3);
 
-	acct->bytes += ((u64)byte_cnt_high << 32) | byte_cnt_low;
-	acct->packets += (pkt_cnt_high << 16) | pkt_cnt_low;
+		acct->bytes += ((u64)byte_cnt_high << 32) | byte_cnt_low;
+		acct->packets += ((u64)pkt_cnt_high << 32) | pkt_cnt_low;
+	} else {
+		byte_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R0_BYTE_CNT_LOW, cnt_r0);
+		byte_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R1_BYTE_CNT_HIGH, cnt_r1);
+		pkt_cnt_low = FIELD_GET(MTK_PPE_MIB_SER_R1_PKT_CNT_LOW, cnt_r1);
+		pkt_cnt_high = FIELD_GET(MTK_PPE_MIB_SER_R2_PKT_CNT_HIGH, cnt_r2);
+
+		acct->bytes += ((u64)byte_cnt_high << 32) | byte_cnt_low;
+		acct->packets += (pkt_cnt_high << 16) | pkt_cnt_low;
+	}
 
 	return acct;
 }
@@ -186,6 +198,20 @@ static u32 mtk_ppe_hash_entry(struct mtk_eth *eth, struct mtk_foe_entry *e)
 	return hash;
 }
 
+static inline u16 *
+mtk_foe_entry_tport(struct mtk_eth *eth, struct mtk_foe_entry *entry)
+{
+	int type = mtk_get_ib1_pkt_type(eth, entry->ib1);
+
+	if (type == MTK_PPE_PKT_TYPE_BRIDGE)
+		return &entry->bridge.tport_id;
+
+	if (type >= MTK_PPE_PKT_TYPE_IPV4_DSLITE)
+		return &entry->ipv6.tport_id;
+
+	return &entry->ipv4.tport_id;
+}
+
 static inline struct mtk_foe_mac_info *
 mtk_foe_entry_l2(struct mtk_eth *eth, struct mtk_foe_entry *entry)
 {
@@ -223,7 +249,8 @@ int mtk_foe_entry_prepare(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 
 	memset(entry, 0, sizeof(*entry));
 
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3)) {
 		val = FIELD_PREP(MTK_FOE_IB1_STATE, MTK_FOE_STATE_BIND) |
 		      FIELD_PREP(MTK_FOE_IB1_PACKET_TYPE_V2, type) |
 		      FIELD_PREP(MTK_FOE_IB1_UDP, l4proto == IPPROTO_UDP) |
@@ -287,7 +314,8 @@ int mtk_foe_entry_set_pse_port(struct mtk_eth *eth,
 	u32 *ib2 = mtk_foe_entry_ib2(eth, entry);
 	u32 val = *ib2;
 
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3)) {
 		val &= ~MTK_FOE_IB2_DEST_PORT_V2;
 		val |= FIELD_PREP(MTK_FOE_IB2_DEST_PORT_V2, port);
 	} else {
@@ -438,7 +466,13 @@ int mtk_foe_entry_set_wdma(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 	struct mtk_foe_mac_info *l2 = mtk_foe_entry_l2(eth, entry);
 	u32 *ib2 = mtk_foe_entry_ib2(eth, entry);
 
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3)) {
+		*ib2 &= ~MTK_FOE_IB2_PORT_MG_V2;
+		*ib2 |=  FIELD_PREP(MTK_FOE_IB2_RX_IDX, txq) |
+			 MTK_FOE_IB2_WDMA_WINFO_V2;
+		l2->winfo_v2 = FIELD_PREP(MTK_FOE_WINFO_WCID_V2, wcid) |
+			       FIELD_PREP(MTK_FOE_WINFO_BSS_V2, bss);
+	} else if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
 		*ib2 &= ~MTK_FOE_IB2_PORT_MG_V2;
 		*ib2 |=  FIELD_PREP(MTK_FOE_IB2_RX_IDX, txq) |
 			 MTK_FOE_IB2_WDMA_WINFO_V2;
@@ -468,7 +502,12 @@ int mtk_foe_entry_set_queue(struct mtk_eth *eth, struct mtk_foe_entry *entry,
 {
 	u32 *ib2 = mtk_foe_entry_ib2(eth, entry);
 
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3)) {
+		u16 *tport_id = mtk_foe_entry_tport(eth, entry);
+		*ib2 &= ~MTK_FOE_IB2_QID_V2;
+		*ib2 |= FIELD_PREP(MTK_FOE_IB2_QID_V2, queue);
+		*tport_id = 1;
+	} else if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
 		*ib2 &= ~MTK_FOE_IB2_QID_V2;
 		*ib2 |= FIELD_PREP(MTK_FOE_IB2_QID_V2, queue);
 		*ib2 |= MTK_FOE_IB2_PSE_QOS_V2;
@@ -648,7 +687,8 @@ __mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_foe_entry *entry,
 	struct mtk_foe_entry *hwe;
 	u32 val;
 
-	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
+	if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3)) {
 		entry->ib1 &= ~MTK_FOE_IB1_BIND_TIMESTAMP_V2;
 		entry->ib1 |= FIELD_PREP(MTK_FOE_IB1_BIND_TIMESTAMP_V2,
 					 timestamp);
@@ -664,7 +704,8 @@ __mtk_foe_entry_commit(struct mtk_ppe *ppe, struct mtk_foe_entry *entry,
 	hwe->ib1 = entry->ib1;
 
 	if (ppe->accounting) {
-		if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2))
+		if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+		    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3))
 			val = MTK_FOE_IB2_MIB_CNT_V2;
 		else
 			val = MTK_FOE_IB2_MIB_CNT;
@@ -958,7 +999,7 @@ static void mtk_ppe_init_foe_table(struct mtk_ppe *ppe)
 
 void mtk_ppe_start(struct mtk_ppe *ppe)
 {
-	u32 val;
+	u32 val = 0;
 
 	if (!ppe)
 		return;
@@ -966,22 +1007,24 @@ void mtk_ppe_start(struct mtk_ppe *ppe)
 	mtk_ppe_init_foe_table(ppe);
 	ppe_w32(ppe, MTK_PPE_TB_BASE, ppe->foe_phys);
 
-	val = MTK_PPE_TB_CFG_ENTRY_80B |
-	      MTK_PPE_TB_CFG_AGE_NON_L4 |
-	      MTK_PPE_TB_CFG_AGE_UNBIND |
-	      MTK_PPE_TB_CFG_AGE_TCP |
-	      MTK_PPE_TB_CFG_AGE_UDP |
-	      MTK_PPE_TB_CFG_AGE_TCP_FIN |
-	      FIELD_PREP(MTK_PPE_TB_CFG_SEARCH_MISS,
-			 MTK_PPE_SEARCH_MISS_ACTION_FORWARD_BUILD) |
-	      FIELD_PREP(MTK_PPE_TB_CFG_KEEPALIVE,
-			 MTK_PPE_KEEPALIVE_DISABLE) |
-	      FIELD_PREP(MTK_PPE_TB_CFG_HASH_MODE, 1) |
-	      FIELD_PREP(MTK_PPE_TB_CFG_SCAN_MODE,
-			 MTK_PPE_SCAN_MODE_KEEPALIVE_AGE) |
-	      FIELD_PREP(MTK_PPE_TB_CFG_ENTRY_NUM,
-			 MTK_PPE_ENTRIES_SHIFT);
-	if (MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V2))
+	if (!MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V3))
+	      val |= MTK_PPE_TB_CFG_ENTRY_80B;
+	val |= MTK_PPE_TB_CFG_AGE_NON_L4 |
+	       MTK_PPE_TB_CFG_AGE_UNBIND |
+	       MTK_PPE_TB_CFG_AGE_TCP |
+	       MTK_PPE_TB_CFG_AGE_UDP |
+	       MTK_PPE_TB_CFG_AGE_TCP_FIN |
+	       FIELD_PREP(MTK_PPE_TB_CFG_SEARCH_MISS,
+			  MTK_PPE_SEARCH_MISS_ACTION_FORWARD_BUILD) |
+	       FIELD_PREP(MTK_PPE_TB_CFG_KEEPALIVE,
+			  MTK_PPE_KEEPALIVE_DISABLE) |
+	       FIELD_PREP(MTK_PPE_TB_CFG_HASH_MODE, 1) |
+	       FIELD_PREP(MTK_PPE_TB_CFG_SCAN_MODE,
+			  MTK_PPE_SCAN_MODE_KEEPALIVE_AGE) |
+	       FIELD_PREP(MTK_PPE_TB_CFG_ENTRY_NUM,
+			  MTK_PPE_ENTRIES_SHIFT);
+	if (MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V3))
 		val |= MTK_PPE_TB_CFG_INFO_SEL;
 	ppe_w32(ppe, MTK_PPE_TB_CFG, val);
 
@@ -997,7 +1040,8 @@ void mtk_ppe_start(struct mtk_ppe *ppe)
 	      MTK_PPE_FLOW_CFG_IP4_NAPT |
 	      MTK_PPE_FLOW_CFG_IP4_DSLITE |
 	      MTK_PPE_FLOW_CFG_IP4_NAT_FRAG;
-	if (MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V2))
+	if (MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V2) ||
+	    MTK_HAS_CAPS(ppe->eth->soc->caps, MTK_NETSYS_V3))
 		val |= MTK_PPE_MD_TOAP_BYP_CRSN0 |
 		       MTK_PPE_MD_TOAP_BYP_CRSN1 |
 		       MTK_PPE_MD_TOAP_BYP_CRSN2 |
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe.h b/drivers/net/ethernet/mediatek/mtk_ppe.h
index fd7ece7..ba71884 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe.h
+++ b/drivers/net/ethernet/mediatek/mtk_ppe.h
@@ -85,6 +85,18 @@ enum {
 #define MTK_FOE_WINFO_BSS		GENMASK(5, 0)
 #define MTK_FOE_WINFO_WCID		GENMASK(15, 6)
 
+/* CONFIG_MEDIATEK_NETSYS_V3 */
+#define MTK_FOE_WINFO_WCID_V2		GENMASK(15, 0)
+#define MTK_FOE_WINFO_BSS_V2		GENMASK(23, 16)
+
+#define MTK_FOE_WINFO_PAO_USR_INFO	GENMASK(15, 0)
+#define MTK_FOE_WINFO_PAO_TID		GENMASK(19, 16)
+#define MTK_FOE_WINFO_PAO_IS_FIXEDRATE	BIT(20)
+#define MTK_FOE_WINFO_PAO_IS_PRIOR	BIT(21)
+#define MTK_FOE_WINFO_PAO_IS_SP		BIT(22)
+#define MTK_FOE_WINFO_PAO_HF		BIT(23)
+#define MTK_FOE_WINFO_PAO_AMSDU_EN	BIT(24)
+
 enum {
 	MTK_FOE_STATE_INVALID,
 	MTK_FOE_STATE_UNBIND,
@@ -106,8 +118,18 @@ struct mtk_foe_mac_info {
 	u16 pppoe_id;
 	u16 src_mac_lo;
 
-	u16 minfo;
-	u16 winfo;
+	union {
+		struct {
+			u16 minfo;
+			u16 winfo;
+		};
+		struct {
+			u16 minfo_v2;
+			u16 _rsv0;
+			u32 winfo_v2;
+			u32 winfo_pao;
+		};
+	};
 };
 
 /* software-only entry type */
@@ -121,6 +143,10 @@ struct mtk_foe_bridge {
 	u32 ib2;
 
 	struct mtk_foe_mac_info l2;
+
+	u8 cdrt_id;
+	u8 tops_entry;
+	u16 tport_id;
 };
 
 struct mtk_ipv4_tuple {
@@ -152,6 +178,10 @@ struct mtk_foe_ipv4 {
 	u32 udf_tsid;
 
 	struct mtk_foe_mac_info l2;
+
+	u8 cdrt_id;
+	u8 tops_entry;
+	u16 tport_id;
 };
 
 struct mtk_foe_ipv4_dslite {
@@ -168,6 +198,10 @@ struct mtk_foe_ipv4_dslite {
 	u32 ib2;
 
 	struct mtk_foe_mac_info l2;
+
+	u8 cdrt_id;
+	u8 tops_entry;
+	u16 tport_id;
 };
 
 struct mtk_foe_ipv6 {
@@ -192,6 +226,10 @@ struct mtk_foe_ipv6 {
 
 	u32 ib2;
 	struct mtk_foe_mac_info l2;
+
+	u8 cdrt_id;
+	u8 tops_entry;
+	u16 tport_id;
 };
 
 struct mtk_foe_ipv6_6rd {
@@ -214,6 +252,10 @@ struct mtk_foe_ipv6_6rd {
 
 	u32 ib2;
 	struct mtk_foe_mac_info l2;
+
+	u8 cdrt_id;
+	u8 tops_entry;
+	u16 tport_id;
 };
 
 struct mtk_foe_entry {
@@ -225,7 +267,7 @@ struct mtk_foe_entry {
 		struct mtk_foe_ipv4_dslite dslite;
 		struct mtk_foe_ipv6 ipv6;
 		struct mtk_foe_ipv6_6rd ipv6_6rd;
-		u32 data[23];
+		u32 data[31];
 	};
 };
 
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
old mode 100755
new mode 100644
index 70f6374..8a20dce
--- a/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
+++ b/drivers/net/ethernet/mediatek/mtk_ppe_offload.c
@@ -194,19 +194,20 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
 	if (mtk_flow_get_wdma_info(dev, dest_mac, &info) == 0) {
 		mtk_foe_entry_set_wdma(eth, foe, info.wdma_idx, info.queue,
 				       info.bss, info.wcid);
-		if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2)) {
+		if (MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ||
+		    MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3)) {
 			switch (info.wdma_idx) {
 			case 0:
-				pse_port = 8;
+				pse_port = PSE_WDMA0_PORT;
 				break;
 			case 1:
-				pse_port = 9;
+				pse_port = PSE_WDMA1_PORT;
 				break;
 			default:
 				return -EINVAL;
 			}
 		} else {
-			pse_port = 3;
+			pse_port = PSE_PPE0_PORT;
 		}
 		*wed_index = info.wdma_idx;
 		goto out;
@@ -215,9 +216,11 @@ mtk_flow_set_output_device(struct mtk_eth *eth, struct mtk_foe_entry *foe,
 	dsa_port = mtk_flow_get_dsa_port(&dev);
 
 	if (dev == eth->netdev[0])
-		pse_port = 1;
+		pse_port = PSE_GDM1_PORT;
 	else if (dev == eth->netdev[1])
-		pse_port = 2;
+		pse_port = PSE_GDM2_PORT;
+	else if (dev == eth->netdev[2])
+		pse_port = PSE_GDM3_PORT;
 	else
 		return -EOPNOTSUPP;
 
@@ -462,7 +465,8 @@ mtk_flow_offload_replace(struct mtk_eth *eth, struct flow_cls_offload *f,
 
 		ctx.dev = idev;
 		idev->netdev_ops->ndo_fill_receive_path(&ctx, &path);
-		num_ppe = MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ? 2 : 1;
+		num_ppe = MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V3) ? 3 :
+			  MTK_HAS_CAPS(eth->soc->caps, MTK_NETSYS_V2) ? 2 : 1;
 		num_ppe = min_t(u32, ARRAY_SIZE(eth->ppe), num_ppe);
 		ppe_index = path.mtk_wdma.wdma_idx;
 		if (ppe_index >= num_ppe) {
diff --git a/drivers/net/ethernet/mediatek/mtk_ppe_regs.h b/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
index a2e61b3..96e50b1 100644
--- a/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
+++ b/drivers/net/ethernet/mediatek/mtk_ppe_regs.h
@@ -159,9 +159,14 @@ enum {
 #define MTK_PPE_MIB_SER_R1			0x344
 #define MTK_PPE_MIB_SER_R1_PKT_CNT_LOW		GENMASK(31, 16)
 #define MTK_PPE_MIB_SER_R1_BYTE_CNT_HIGH	GENMASK(15, 0)
+#define MTK_PPE_MIB_SER_R1_BYTE_CNT_HIGH_V2	GENMASK(31, 0)
 
 #define MTK_PPE_MIB_SER_R2			0x348
 #define MTK_PPE_MIB_SER_R2_PKT_CNT_HIGH		GENMASK(23, 0)
+#define MTK_PPE_MIB_SER_R2_PKT_CNT_LOW_V2	GENMASK(31, 0)
+
+#define MTK_PPE_MIB_SER_R3			0x34C
+#define MTK_PPE_MIB_SER_R3_PKT_CNT_HIGH_V2	GENMASK(31, 0)
 
 #define MTK_PPE_MIB_CACHE_CTL			0x350
 #define MTK_PPE_MIB_CACHE_CTL_EN		BIT(0)
-- 
2.18.0

